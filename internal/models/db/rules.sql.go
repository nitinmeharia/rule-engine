// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rules.sql

package db

import (
	"context"
)

const CreateRule = `-- name: CreateRule :exec
INSERT INTO rules (namespace, rule_id, version, status, logic, conditions, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateRuleParams struct {
	Namespace  string  `json:"namespace"`
	RuleID     string  `json:"ruleId"`
	Version    int32   `json:"version"`
	Status     *string `json:"status"`
	Logic      *string `json:"logic"`
	Conditions []byte  `json:"conditions"`
	CreatedBy  string  `json:"createdBy"`
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) error {
	_, err := q.db.Exec(ctx, CreateRule,
		arg.Namespace,
		arg.RuleID,
		arg.Version,
		arg.Status,
		arg.Logic,
		arg.Conditions,
		arg.CreatedBy,
	)
	return err
}

const DeactivateRule = `-- name: DeactivateRule :exec
UPDATE rules
SET status = 'inactive'
WHERE namespace = $1 AND rule_id = $2 AND status = 'active'
`

type DeactivateRuleParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
}

func (q *Queries) DeactivateRule(ctx context.Context, arg DeactivateRuleParams) error {
	_, err := q.db.Exec(ctx, DeactivateRule, arg.Namespace, arg.RuleID)
	return err
}

const DeleteRule = `-- name: DeleteRule :exec
DELETE FROM rules
WHERE namespace = $1 AND rule_id = $2 AND version = $3
`

type DeleteRuleParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
	Version   int32  `json:"version"`
}

func (q *Queries) DeleteRule(ctx context.Context, arg DeleteRuleParams) error {
	_, err := q.db.Exec(ctx, DeleteRule, arg.Namespace, arg.RuleID, arg.Version)
	return err
}

const GetActiveRuleVersion = `-- name: GetActiveRuleVersion :one
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1 AND rule_id = $2 AND status = 'active'
`

type GetActiveRuleVersionParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
}

func (q *Queries) GetActiveRuleVersion(ctx context.Context, arg GetActiveRuleVersionParams) (*Rule, error) {
	row := q.db.QueryRow(ctx, GetActiveRuleVersion, arg.Namespace, arg.RuleID)
	var i Rule
	err := row.Scan(
		&i.Namespace,
		&i.RuleID,
		&i.Version,
		&i.Status,
		&i.Logic,
		&i.Conditions,
		&i.CreatedBy,
		&i.PublishedBy,
		&i.CreatedAt,
		&i.PublishedAt,
	)
	return &i, err
}

const GetDraftRuleVersion = `-- name: GetDraftRuleVersion :one
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1 AND rule_id = $2 AND status = 'draft'
`

type GetDraftRuleVersionParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
}

func (q *Queries) GetDraftRuleVersion(ctx context.Context, arg GetDraftRuleVersionParams) (*Rule, error) {
	row := q.db.QueryRow(ctx, GetDraftRuleVersion, arg.Namespace, arg.RuleID)
	var i Rule
	err := row.Scan(
		&i.Namespace,
		&i.RuleID,
		&i.Version,
		&i.Status,
		&i.Logic,
		&i.Conditions,
		&i.CreatedBy,
		&i.PublishedBy,
		&i.CreatedAt,
		&i.PublishedAt,
	)
	return &i, err
}

const GetMaxRuleVersion = `-- name: GetMaxRuleVersion :one
SELECT COALESCE(MAX(version), 0) as max_version
FROM rules
WHERE namespace = $1 AND rule_id = $2
`

type GetMaxRuleVersionParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
}

func (q *Queries) GetMaxRuleVersion(ctx context.Context, arg GetMaxRuleVersionParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, GetMaxRuleVersion, arg.Namespace, arg.RuleID)
	var max_version interface{}
	err := row.Scan(&max_version)
	return max_version, err
}

const GetRule = `-- name: GetRule :one
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1 AND rule_id = $2 AND version = $3
`

type GetRuleParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
	Version   int32  `json:"version"`
}

func (q *Queries) GetRule(ctx context.Context, arg GetRuleParams) (*Rule, error) {
	row := q.db.QueryRow(ctx, GetRule, arg.Namespace, arg.RuleID, arg.Version)
	var i Rule
	err := row.Scan(
		&i.Namespace,
		&i.RuleID,
		&i.Version,
		&i.Status,
		&i.Logic,
		&i.Conditions,
		&i.CreatedBy,
		&i.PublishedBy,
		&i.CreatedAt,
		&i.PublishedAt,
	)
	return &i, err
}

const ListActiveRules = `-- name: ListActiveRules :many
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1 AND status = 'active'
ORDER BY rule_id ASC
`

func (q *Queries) ListActiveRules(ctx context.Context, namespace string) ([]*Rule, error) {
	rows, err := q.db.Query(ctx, ListActiveRules, namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Rule{}
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.Namespace,
			&i.RuleID,
			&i.Version,
			&i.Status,
			&i.Logic,
			&i.Conditions,
			&i.CreatedBy,
			&i.PublishedBy,
			&i.CreatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRuleVersions = `-- name: ListRuleVersions :many
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1 AND rule_id = $2
ORDER BY version DESC
`

type ListRuleVersionsParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
}

func (q *Queries) ListRuleVersions(ctx context.Context, arg ListRuleVersionsParams) ([]*Rule, error) {
	rows, err := q.db.Query(ctx, ListRuleVersions, arg.Namespace, arg.RuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Rule{}
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.Namespace,
			&i.RuleID,
			&i.Version,
			&i.Status,
			&i.Logic,
			&i.Conditions,
			&i.CreatedBy,
			&i.PublishedBy,
			&i.CreatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRules = `-- name: ListRules :many
SELECT namespace, rule_id, version, status, logic, conditions, created_by, published_by, created_at, published_at
FROM rules
WHERE namespace = $1
ORDER BY rule_id ASC, version DESC
`

func (q *Queries) ListRules(ctx context.Context, namespace string) ([]*Rule, error) {
	rows, err := q.db.Query(ctx, ListRules, namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Rule{}
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.Namespace,
			&i.RuleID,
			&i.Version,
			&i.Status,
			&i.Logic,
			&i.Conditions,
			&i.CreatedBy,
			&i.PublishedBy,
			&i.CreatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PublishRule = `-- name: PublishRule :exec
UPDATE rules
SET status = 'active', published_by = $4, published_at = now()
WHERE namespace = $1 AND rule_id = $2 AND version = $3
`

type PublishRuleParams struct {
	Namespace   string  `json:"namespace"`
	RuleID      string  `json:"ruleId"`
	Version     int32   `json:"version"`
	PublishedBy *string `json:"publishedBy"`
}

func (q *Queries) PublishRule(ctx context.Context, arg PublishRuleParams) error {
	_, err := q.db.Exec(ctx, PublishRule,
		arg.Namespace,
		arg.RuleID,
		arg.Version,
		arg.PublishedBy,
	)
	return err
}

const RuleExists = `-- name: RuleExists :one
SELECT EXISTS(
    SELECT 1 FROM rules
    WHERE namespace = $1 AND rule_id = $2 AND version = $3
)
`

type RuleExistsParams struct {
	Namespace string `json:"namespace"`
	RuleID    string `json:"ruleId"`
	Version   int32  `json:"version"`
}

func (q *Queries) RuleExists(ctx context.Context, arg RuleExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, RuleExists, arg.Namespace, arg.RuleID, arg.Version)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const UpdateRule = `-- name: UpdateRule :exec
UPDATE rules
SET logic = $4, conditions = $5, created_by = $6
WHERE namespace = $1 AND rule_id = $2 AND version = $3
`

type UpdateRuleParams struct {
	Namespace  string  `json:"namespace"`
	RuleID     string  `json:"ruleId"`
	Version    int32   `json:"version"`
	Logic      *string `json:"logic"`
	Conditions []byte  `json:"conditions"`
	CreatedBy  string  `json:"createdBy"`
}

func (q *Queries) UpdateRule(ctx context.Context, arg UpdateRuleParams) error {
	_, err := q.db.Exec(ctx, UpdateRule,
		arg.Namespace,
		arg.RuleID,
		arg.Version,
		arg.Logic,
		arg.Conditions,
		arg.CreatedBy,
	)
	return err
}
